const gulp = require('gulp');
const Figma = require('figma-api');
const prompt = require('gulp-prompt');
const chalk = require('chalk');
const { JSONPath } = require('jsonpath-plus');
const Vinyl = require('vinyl');
const { cleanForSlug } = require('@wordpress/url');
const gulpStylelint = require('@ronilaukkarinen/gulp-stylelint');
const fs = require('fs');
const path = require('path');
const download = require('image-downloader');

const fileHeader = `// Note: do not edit this file directly. All content is generated automatically via the 'gulp figma' task.\n\n`;

let settings;

gulp.task('figma:init', (done) => {
	settings = JSON.parse(
		fs.readFileSync(
			path.resolve(
				`css${path.sep}__base-includes${path.sep}figma${path.sep}figma-settings.json`
			)
		)
	);

	done();
});

gulp.task('figma:setup', (done) => {
	const promptSettings = [
		{
			type: 'confirm',
			name: 'importStyles',
			message: chalk.blue(
				'Do you want to import font and color styles from Figma?'
			),
			default: false,
		},
	];

	return gulp.src('./package.json').pipe(
		prompt.prompt(promptSettings, function (response) {
			if (true === response.importStyles) {
				const figma = gulp.series('figma');
				figma();
			}

			done();
		})
	);
});

gulp.task('figma:run', async (done) => {
	const promptSettings = [
		{
			type: 'input',
			name: 'apiToken',
			message: chalk.blue('Figma API token (found in 1password):'),
			validate(input) {
				if ('' === input) {
					return chalk.red('API token required.');
				}

				return true;
			},
		},
		{
			type: 'confirm',
			name: 'importIcons',
			message: chalk.blue(
				'Do you want to download the latest icons from Figma?'
			),
			default: false,
		},
	];

	if (!settings.figmaFileID) {
		promptSettings.push({
			type: 'input',
			name: 'figmaFileID',
			message: chalk.blue(
				'Figma File ID (found in the Figma URL for the project: https://www.figma.com/file/THIS_IS_THE_FILE_ID/...):'
			),
			validate(input) {
				if ('' === input) {
					return chalk.red('Figma File ID required.');
				}

				return true;
			},
		});
	}

	await new Promise((resolve) => {
		gulp.src('./package.json')
			.pipe(
				prompt.prompt(promptSettings, function (response) {
					const api = new Figma.Api({
						personalAccessToken: response.apiToken,
					});

					let figmaFileID;

					if (settings.figmaFileID) {
						figmaFileID = settings.figmaFileID;
					} else {
						figmaFileID = response.figmaFileID;
					}

					// Get font styles.
					api.getFileNodes(figmaFileID, ['7217:93231']).then(
						(file) => {
							const fontRows = JSONPath({
								path: '$..document..children[?(@.type==="FRAME" && @.name==="Content")]',
								json: file,
							});

							const fontJSON = {
								fontStyles: {},
							};

							if (fontRows) {
								fontRows.forEach((fontRow) => {
									if (
										fontRow.children &&
										fontRow.children[0] &&
										fontRow.children[1]
									) {
										let fontData = {};

										if (
											'Mobile' ===
											fontRow.children[1].name
										) {
											if (
												fontRow.children[0].children &&
												fontRow.children[1].children
											) {
												fontData = getFontData(
													fontRow.children[0]
														.children[0],
													fontRow.children[1]
														.children[0]
												);
											}
										} else if (
											'Universal' ===
											fontRow.children[1].name
										) {
											fontData = getFontData(
												fontRow.children[0],
												fontRow.children[0]
											);
										}

										if (fontData.name) {
											fontJSON.fontStyles[
												cleanForSlug(fontData.name)
											] = fontData;
										}
									}
								});
							}

							let fontVariables =
								parseJSONtoSCSSVariables(fontJSON);

							fontVariables = fontVariables.join('');
							fontVariables = fontVariables.replace(/,\s*$/, '');

							const stream = gulp.src(`.`);

							const variablesFile = new Vinyl({
								path: `.${path.sep}css${path.sep}__base-includes${path.sep}figma${path.sep}_figma-font-variables.scss`,
								contents: Buffer.from(
									fileHeader + fontVariables
								),
								//contents: Buffer.from(
								//	JSON.stringify(fontJSON, null, '\t')
								//),
							});

							stream.write(variablesFile);

							let fontMixins = parseJSONtoSCSSMixins(
								fontJSON.fontStyles
							);

							fontMixins = fontMixins.join('');
							fontMixins = fontMixins.replace(/,\s*$/, '');

							const mixinsFile = new Vinyl({
								path: `.${path.sep}css${path.sep}__base-includes${path.sep}figma${path.sep}_figma-font-styles.scss`,
								contents: Buffer.from(fileHeader + fontMixins),
							});

							stream.write(mixinsFile);

							stream
								.pipe(
									gulpStylelint({
										fix: true,
										failAfterError: false,
										reporters: [
											{
												formatter: 'string',
												console: true,
											},
										],
									})
								)
								.pipe(gulp.dest('.'));
						},
						(error) => {
							if (
								error.response &&
								error.response.data &&
								error.response.data.status &&
								error.response.data.err
							) {
								console.log(
									chalk.red(
										`Error retrieving font styles from Figma. Error code ${error.response.data.status}: ${error.response.data.err}`
									)
								);
							} else {
								console.log(
									chalk.red(
										`Error retrieving font styles from Figma.`
									)
								);
							}
						}
					);

					// Get color styles.
					api.getFileNodes(figmaFileID, ['7217:93268']).then(
						(file) => {
							const colorNodes = JSONPath({
								path: '$..document..children[?(@.name.match(/.*-Color/gm))]',
								json: file,
							});

							const colorJSON = {
								colorStyles: {},
							};

							const paints = [];

							if (colorNodes) {
								colorNodes.forEach((colorNode) => {
									if (
										colorNode.fills &&
										colorNode.fills[0] &&
										colorNode.children
									) {
										const paint = colorNode.fills[0];

										if ('IMAGE' === paint.type) {
											return;
										}

										let value;
										if ('SOLID' === paint.type) {
											value = `#${colorToHex(
												paint.color
											)}`;
										}

										let name = '';

										colorNode.children.forEach((child) => {
											if (
												'' === name &&
												child.characters &&
												!child.characters.includes('#')
											) {
												name = child.characters;
											}
										});

										if (
											'' !== name &&
											'Color-Name' !== name
										) {
											paints.push({
												name,
												slug: cleanForSlug(name),
												type: paint.type,
												value,
											});
										}
									}
								});
							}

							if (paints.length) {
								const colorVariables =
									generatePaintsSCSS(paints);

								const stream = gulp.src(`.`);

								const variablesFile = new Vinyl({
									path: `./css${path.sep}__base-includes${path.sep}figma${path.sep}_figma-color-variables.scss`,
									contents: Buffer.from(
										fileHeader + colorVariables
									),
								});

								stream.write(variablesFile);

								stream
									.pipe(
										gulpStylelint({
											fix: true,
											failAfterError: false,
											reporters: [
												{
													formatter: 'string',
													console: true,
												},
											],
										})
									)
									.pipe(gulp.dest('.'));
							}
						},
						(error) => {
							if (
								error.response &&
								error.response.data &&
								error.response.data.status &&
								error.response.data.err
							) {
								console.log(
									chalk.red(
										`Error retrieving color styles from Figma. Error code ${error.response.data.status}: ${error.response.data.err}`
									)
								);
							} else {
								console.log(
									chalk.red(
										`Error retrieving color styles from Figma.`
									)
								);
							}
						}
					);

					if (true === response.importIcons) {
						// Get icons.
						api.getFileNodes(figmaFileID, ['7217:93221']).then(
							(file) => {
								const iconNodes = JSONPath({
									path: '$..document..children[?(@.type==="COMPONENT")]',
									json: file,
								});

								const icons = [];

								if (iconNodes) {
									iconNodes.forEach((iconNode) => {
										if (
											iconNode.children &&
											1 === iconNode.children.length
										) {
											if (
												iconNode.children[0] &&
												'VECTOR' ===
													iconNode.children[0].type
											) {
												iconNode.name =
													iconNode.children[0].name;
												icons.push(iconNode);
											}
										}
									});
								}

								if (icons.length) {
									getFigmaIcons(icons, api, figmaFileID).then(
										() => {
											resolve();
											done();
										}
									);
								} else {
									console.log(
										chalk.red(
											`No icons found in the Figma file.`
										)
									);

									resolve();
									done();
								}
							},
							(error) => {
								if (
									error.response &&
									error.response.data &&
									error.response.data.status &&
									error.response.data.err
								) {
									console.log(
										chalk.red(
											`Error retrieving icons from Figma. Error code ${error.response.data.status}: ${error.response.data.err}`
										)
									);
								} else {
									console.log(
										chalk.red(
											`Error retrieving icons from Figma.`
										)
									);
								}

								resolve();
								done();
							}
						);
					} else {
						resolve();
						done();
					}
				})
			)
			.on('finish', done);
	});
});

gulp.task('figma', gulp.series('figma:init', 'figma:run'));

const getFontData = (desktopValues, mobileValues) => {
	const properties = [
		['fontFamily', 'font-family'],
		['fontSize', 'font-size'],
		['fontPostScriptName', 'fontPostScriptName'],
		['lineHeightPx', 'line-height'],
		['paragraphSpacing', 'margin-bottom'],
		['fontWeight', 'font-weight'],
		['letterSpacing', 'letter-spacing'],
		['italic', 'font-style'],
		['textDecoration', 'text-decoration'],
		['textCase', 'text-transform'],
	];

	const fontData = {
		name: '',
		desktop: {},
		mobile: {},
	};

	fontData.name = `"${desktopValues.characters}"`;

	properties.forEach((property) => {
		let desktopValue = desktopValues.style[property[0]];
		let mobileValue = mobileValues.style[property[0]];

		if (undefined !== desktopValue) {
			if ('italic' === property[0]) {
				if (true === desktopValue) {
					fontData.desktop[property[1]] = 'italic';
					fontData.mobile[property[1]] = 'italic';
				}
			} else if ('text-transform' === property[1]) {
				if ('UPPER' === desktopValue) {
					fontData.desktop[property[1]] = 'uppercase';
					fontData.mobile[property[1]] = 'uppercase';
				}
			} else if ('letter-spacing' === property[1]) {
				if (desktopValue > 0 || mobileValue > 0) {
					fontData.desktop[property[1]] =
						Math.round(desktopValue * 10000) / 10000;
					fontData.mobile[property[1]] =
						Math.round(mobileValue * 10000) / 10000;
				}
			} else if (
				'number' === typeof desktopValue ||
				'boolean' === typeof desktopValue ||
				'text-decoration' === property[1]
			) {
				if ('string' === typeof desktopValue) {
					desktopValue = desktopValue.toLowerCase();
					mobileValue = mobileValue.toLowerCase();
				}

				fontData.desktop[property[1]] = desktopValue;
				fontData.mobile[property[1]] = mobileValue;
			} else if ('string' === typeof desktopValue) {
				fontData.desktop[property[1]] = `"${desktopValue}"`;
				fontData.mobile[property[1]] = `"${mobileValue}"`;
			}
		}
	});

	return fontData;
};

const parseJSONtoSCSSVariables = (jsonObject, output = [], level = 0) => {
	for (const [key, value] of Object.entries(jsonObject)) {
		if (0 === level) {
			output.push('$');
		}

		for (let i = 0; i < level; i++) {
			output.push(`\t`);
		}

		if ('object' === typeof value) {
			output.push(`${key}: (\n`);
			output.push(parseJSONtoSCSSVariables(value, output, level + 1));

			for (let i = 0; i < level; i++) {
				output.push(`\t`);
			}

			output.push('),\n');
		} else {
			output.push(`${key}: ${value},\n`);
		}
	}

	return output;
};

const parseJSONtoSCSSMixins = (jsonObject, output = []) => {
	for (const [key, value] of Object.entries(jsonObject)) {
		output.push(`@mixin ${key}($margins: true) {\n`);
		output.push(getCSSProperty(key, value, 'font-weight'));
		output.push(getCSSProperty(key, value, 'font-size'));
		output.push(getCSSProperty(key, value, 'font-family'));
		output.push(getCSSProperty(key, value, 'line-height'));
		output.push(getCSSProperty(key, value, 'text-decoration'));
		output.push(getCSSProperty(key, value, 'font-style'));
		output.push(getCSSProperty(key, value, 'letter-spacing'));
		output.push(getCSSProperty(key, value, 'text-transform'));

		if (
			value.desktop['margin-bottom'] ||
			(settings &&
				settings.fontStyles &&
				settings.fontStyles[key] &&
				settings.fontStyles[key]['margin-top'])
		) {
			output.push(`\n\t@if ($margins) {\n`);

			if (value.desktop['margin-bottom']) {
				if (
					settings &&
					settings.fontStyles &&
					settings.fontStyles[key] &&
					settings.fontStyles[key]['margin-top-multiplier']
				) {
					output.push(
						`\t\tmargin-top: calc(var(--${key}-margin-bottom) * ${settings.fontStyles[key]['margin-top-multiplier']});\n`
					);
				}

				output.push(
					`\t\tmargin-bottom: var(--${key}-margin-bottom);\n\n`
				);

				output.push(
					`\t\t&:first-child {\n\t\t\tmargin-top: 0;\n\t\t}\n`
				);

				output.push(
					`\t\t&:last-child {\n\t\t\tmargin-bottom: 0;\n\t\t}\n`
				);
			}

			output.push(`\t}\n`);
		}

		output.push(`\n\t@if (mixin-exists(${key}-custom)) {\n`);
		output.push(`\t\t@include ${key}-custom();\n`);
		output.push(`\t}\n`);

		output.push(`}\n\n`);
	}

	return output;
};

const getCSSProperty = (key, value, attribute) => {
	if (value.desktop[attribute]) {
		return `\t${attribute}: var(--${key}-${attribute});\n`;
	}
};

const colorToHex = (color) => {
	let hex = '';

	const rgb = figmaRGBToWebRGB(color);
	hex += ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2])
		.toString(16)
		.slice(1);

	return hex;
};

const figmaRGBToWebRGB = (color) => {
	const namesRGB = ['r', 'g', 'b'];
	const rgb = [];

	namesRGB.forEach((e, i) => {
		rgb[i] = Math.round(color[e] * 255);
	});

	return rgb;
};

// from https://math.stackexchange.com/a/2888105
const decomposeRelativeTransform = (t1, t2) => {
	const a = t1[0];
	const b = t1[1];
	const c = t1[2];
	const d = t2[0];
	const e = t2[1];
	const f = t2[2];

	const delta = a * d - b * c;

	const result = {
		translation: [e, f],
		rotation: 0,
		scale: [0, 0],
		skew: [0, 0],
	};

	// Apply the QR-like decomposition.
	if (a !== 0 || b !== 0) {
		const r = Math.sqrt(a * a + b * b);
		result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
		result.scale = [r, delta / r];
		result.skew = [Math.atan((a * c + b * d) / (r * r)), 0];
	}

	return result;
};

const generatePaintsSCSS = (paints) => {
	let output = '$paints: (\n';
	paints.forEach((paint) => {
		output += `\t${paint.slug}: ${paint.value},\n`;
	});
	output += ');';

	return output;
};

const downloadIcon = (icon, file, iconDirectory) => {
	return new Promise((resolve) => {
		if (file.images[icon.id]) {
			const options = {
				url: file.images[icon.id],
				dest: `${iconDirectory}${path.sep}${icon.name}.svg`,
			};

			download
				.image(options)
				.then(({ filename }) => {
					console.log('Saved to', filename);

					const fileContents = fs.readFileSync(filename);

					if (fileContents.includes('evenodd')) {
						console.log(
							chalk.yellow(
								`Evenodd rule found in icon. Might have issues rendering. Ask design team to remove. For: ${icon.name} ${filename}`
							)
						);
					}

					if (fileContents.includes('clip-path')) {
						console.log(
							chalk.red(
								`Clip path found in icon. Ask design team to remove. For: ${icon.name} ${filename}`
							)
						);
					}

					resolve();
				})
				.catch((err) => {
					console.error(err);
					resolve();
				});
		} else {
			console.log(
				chalk.red(`Error retrieving Figma icon for: ${icon.name}`)
			);
			resolve();
		}
	});
};

const getFigmaIcons = async (icons, api, figmaFileID) => {
	return new Promise((resolve) => {
		const iconIds = icons.map((icon) => {
			return icon.id;
		});

		const iconDirectory = path.resolve(`images${path.sep}icons${path.sep}`);

		fs.mkdirSync(iconDirectory, { recursive: true });

		api.getImage(figmaFileID, { ids: [iconIds], format: 'svg' }).then(
			(file) => {
				if (file.images) {
					Promise.all(
						icons.map((icon) =>
							downloadIcon(icon, file, iconDirectory)
						)
					).then(() => {
						resolve();
					});
				}
			},
			(error) => {
				if (
					error.response &&
					error.response.data &&
					error.response.data.status &&
					error.response.data.err
				) {
					console.log(
						chalk.red(
							`Error retrieving Figma icon. Error code ${error.response.data.status}: ${error.response.data.err}`
						)
					);
				} else {
					console.log(chalk.red(`Error retrieving Figma icon.`));
				}
			}
		);
	});
};
